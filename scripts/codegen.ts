#!/usr/bin/env zx
import { convertCase } from '@axelarjs/utils/case-conversion';
import { capitalize } from '@axelarjs/utils/string';

import fs from 'fs/promises';
import path from 'path';
import prettier from 'prettier';
import { $, glob } from 'zx';

$.verbose = false;

const pascalToKebabCase = convertCase('PascalCase', 'kebab-case');

type ABIInputItem = {
    name: string;
    type: string;
};

type ABIItem = {
    name: string;
    type: string;
    inputs: {
        name: string;
        type: string;
    }[];
};

const getInputType = (input: ABIInputItem) => {
    switch (input.type) {
        // string types
        case 'address':
        case 'bytes32':
        case 'bytes':
            return '`0x${string}`';
        case 'string':
            return 'string';
        // number types
        case 'uint256':
            return 'bigint';
        case 'uint8':
            return 'number';
        // boolean
        case 'bool':
            return 'boolean';
        // default
        default:
            return 'any';
    }
};

/**
 * Represents the contract folders to be codegen'd under artifacts/contracts
 */
const CONTRACT_FOLDERS = ['InterchainTokenService.sol', 'InterchainTokenFactory.sol', 'interchain-token', 'token-manager'];

/**
 * Extracts the contract formatted name and path from the folder name
 *
 * @param folderPath
 */
function extractContractNameAndPath(folderPath: string) {
    const pascalName = path.basename(folderPath).replace(/.sol$/, '');

    return {
        pascalName,
        kebabName: pascalToKebabCase(pascalName),
        abiPath: path.join(folderPath, `${pascalName}.json`),
    };
}

async function main(
    contractFolder: string,
    options: {
        excludePatterns?: string[];
        outputFolder?: string;
    }
) {
    const contractFolders = await glob(`${contractFolder}/**/**.sol`, {
        onlyDirectories: true,
        ignore: options.excludePatterns?.flatMap((pattern) => [`${pattern}/**`, `${contractFolder}/${pattern}/**`, `**/${pattern}/**`]),
    });

    for (const contractFolder of contractFolders) {
        const { pascalName, abiPath } = extractContractNameAndPath(contractFolder);

        const { stdout: abiFileJson } = await $`cat ./${abiPath}`;

        if (!abiFileJson) {
            console.log(`ABI file not found: ${abiPath}`);
            continue;
        }

        const GENERATED_DISCLAIMER = `
            /* eslint-disable @typescript-eslint/no-explicit-any */
            /**
             * This file was generated by scripts/codegen.ts
             *
             * Original abi file:
             * - ${abiPath}
             *
             * DO NOT EDIT MANUALLY
             */
            `;

        const { abi, contractName } = JSON.parse(abiFileJson) as {
            abi: ABIItem[];
            contractName: string;
        };

        const abiJsonFile = `${JSON.stringify({ contractName, abi }, null, 2)}`;

        const outputPath = path.join(path.resolve(options.outputFolder ?? ''), pascalName);

        // only generate args file if there are functions with inputs
        const abiFns = abi.filter((x) => x.type === 'function' && x.inputs.length && x.inputs.every((input) => input.name));

        const argsFile = `
            import { encodeFunctionData } from "viem";

            import ABI_FILE from "./${pascalName}.abi";

            ${abiFns
                .map(({ name, inputs }) => {
                    const argNames = inputs.map(({ name = '' }) => name).join(', ');

                    const argsType = inputs.map((input) => `${input.name}: ${getInputType(input)}`).join('; ');

                    const fnName = capitalize(name);
                    const typeName = `${pascalName}${fnName}Args`;

                    return `
                    export type ${typeName} = {${argsType}}

                    /**
                     * Factory function for ${pascalName}.${name} function args
                     */
                    export const encode${pascalName}${fnName}Args = ({${argNames}}: ${typeName}) => [${argNames}] as const;

                    /**
                     * Encoder function for ${pascalName}.${name} function data
                     */
                    export const encode${pascalName}${fnName}Data = ({${argNames}}: ${typeName}) => encodeFunctionData({
                    functionName: "${name}",
                    abi: ABI_FILE.abi,
                    args:[${argNames}]
                    });
                `;
                })
                .join('\n\n')}
            `;

        const abiFile = `
            export default ${abiJsonFile} as const;
            `;

        // create base path folder
        await $`mkdir -p ${outputPath}`;

        const files = [
            {
                name: `${pascalName}.abi.ts`,
                content: abiFile,
                parser: 'babel-ts',
            },
            {
                name: `${pascalName}.args.ts`,
                content: argsFile,
                parser: 'babel-ts',
                excluded: !abiFns.length,
            },
        ].filter(({ excluded }) => !excluded);

        // write files
        await Promise.all(
            files.map(async ({ name, content, parser }) =>
                fs.writeFile(
                    path.join(outputPath, name),
                    prettier.format(parser === 'json' ? content : `${GENERATED_DISCLAIMER}\n\n${content}`, { parser })
                )
            )
        );

        console.info(`Synced "${pascalName}" contract ABI.`, {
            functions: abiFns.length,
        });
        console.info(`Synced ${CONTRACT_FOLDERS.length} contract ABIs.\n`, `Generated code can be found in the typescript directory`);
    }
}

const CONTRACT_FOLDER = 'artifacts/contracts';
const EXCLUDED_SUBFOLDERS = ['test'];

main(CONTRACT_FOLDER, {
    excludePatterns: EXCLUDED_SUBFOLDERS,
    outputFolder: 'typescript/contracts',
}).catch((err) => {
    console.error(err);
    process.exit(1);
});
