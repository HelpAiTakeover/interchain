#!/usr/bin/env zx
import { convertCase } from '@axelarjs/utils/case-conversion';
import { capitalize } from '@axelarjs/utils/string';

import fs from 'fs/promises';
import path from 'path';
import prettier from 'prettier';
import { $ } from 'zx';

$.verbose = false;

const kebabToPascalCase = convertCase('kebab-case', 'PascalCase');
const pascalToKebabCase = convertCase('PascalCase', 'kebab-case');

type ABIInputItem = {
    name: string;
    type: string;
};

type ABIItem = {
    name: string;
    type: string;
    inputs: {
        name: string;
        type: string;
    }[];
};

const getInputType = (input: ABIInputItem) => {
    switch (input.type) {
        // string types
        case 'address':
        case 'bytes32':
        case 'bytes':
            return '`0x${string}`';
        case 'string':
            return 'string';
        // number types
        case 'uint256':
            return 'bigint';
        case 'uint8':
            return 'number';
        // boolean
        case 'bool':
            return 'boolean';
        // default
        default:
            return 'any';
    }
};

/**
 * Represents the contract folders to be codegen'd under artifacts/contracts
 */
const CONTRACT_FOLDERS = ['InterchainTokenService.sol', 'InterchainTokenFactory.sol', 'interchain-token', 'token-manager'];

/**
 * Extracts the contract formatted name and path from the folder name
 *
 * @param folder
 */
function extractContractNameAndPath(folder: string) {
    if (folder.endsWith('.sol')) {
        const [pascalName] = folder.split('.');

        return {
            pascalName,
            kebabName: pascalToKebabCase(pascalName ?? ''),
            abiPath: path.join(folder, `${pascalName}.json`),
        };
    }

    const pascalName = kebabToPascalCase(folder);

    return {
        pascalName,
        kebabName: folder,
        abiPath: path.join(folder, `${pascalName}.sol`, `${pascalName}.json`),
    };
}

async function main(contractFolders: string[]) {
    for (const contractFolder of contractFolders) {
        const { pascalName, kebabName, abiPath } = extractContractNameAndPath(contractFolder);

        const abiJsonFullPath = path.join('artifacts', 'contracts', abiPath);

        const { stdout: abiFileJson } = await $`cat ./${abiJsonFullPath}`;

        const GENERATED_DISCLAIMER = `
            /* eslint-disable @typescript-eslint/no-explicit-any */
            /**
             * This file was generated by scripts/codegen.ts
             * 
             * Original abi file: 
             * - ${abiJsonFullPath}
             * 
             * DO NOT EDIT MANUALLY
             */
            `;

        const { abi, contractName } = JSON.parse(abiFileJson) as {
            abi: ABIItem[];
            contractName: string;
        };

        const abiJsonFile = `${JSON.stringify({ contractName, abi }, null, 2)}`;

        const outputPath = path.join('typescript', 'contracts', kebabName);

        // only generate args file if there are functions with inputs
        const abiFns = abi.filter((x) => x.type === 'function' && x.inputs.length && x.inputs.every((input) => input.name));

        const argsFile = `
            import { encodeFunctionData } from "viem";

            import ABI_FILE from "./${kebabName}.abi";

            ${abiFns
                .map(({ name, inputs }) => {
                    const argNames = inputs.map(({ name = '' }) => name).join(', ');

                    const argsType = inputs.map((input) => `${input.name}: ${getInputType(input)}`).join('; ');

                    const fnName = capitalize(name);
                    const typeName = `${pascalName}${fnName}Args`;

                    return `
                    export type ${typeName} = {${argsType}}
        
                    /**
                     * Factory function for ${pascalName}.${name} function args
                     */
                    export const encode${pascalName}${fnName}Args = ({${argNames}}: ${typeName}) => [${argNames}] as const;
        
                    /**
                     * Encoder function for ${pascalName}.${name} function data
                     */
                    export const encode${pascalName}${fnName}Data = ({${argNames}}: ${typeName}) => encodeFunctionData({
                    functionName: "${name}",
                    abi: ABI_FILE.abi,
                    args:[${argNames}]
                    });
                `;
                })
                .join('\n\n')}
            `;

        const abiFile = `
            export default ${abiJsonFile} as const;
            `;

        // create base path folder
        await $`mkdir -p ${outputPath}`;

        const files = [
            {
                name: `${kebabName}.abi.ts`,
                content: abiFile,
                parser: 'babel-ts',
            },
            {
                name: `${kebabName}.args.ts`,
                content: argsFile,
                parser: 'babel-ts',
            },
        ];

        // write files
        await Promise.all(
            files.map(async ({ name, content, parser }) =>
                fs.writeFile(
                    path.join(outputPath, name),
                    prettier.format(parser === 'json' ? content : `${GENERATED_DISCLAIMER}\n\n${content}`, { parser })
                )
            )
        );

        console.info(`Synced "${pascalName}" contract ABI.`, {
            functions: abiFns.length,
        });
        console.info(`Synced ${CONTRACT_FOLDERS.length} contract ABIs.\n`, `Generated code can be found in the typescript directory`);
    }
}

main(CONTRACT_FOLDERS).catch((err) => {
    console.error(err);
    process.exit(1);
});
